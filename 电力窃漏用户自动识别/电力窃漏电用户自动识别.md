---
title: 电力窃漏电用户自动识别
comments: false
date: 2018-07-01 09:15:37
tags: 数据分析
categories: 技术篇
---
<font color=blue>前言：这是一次很简单的实战，因为模型已经建好了，只剩下数据分析。</font>        
      
**<font size=3>背景</font>**     
实战的项目是建立一个数据分析模型，来自动识别窃漏电用户。该模型以电力系统采集到的用户的各相电流、电压、功率因数等用电负荷数据以及用电异常等终端报警信息为基础数据，同时给出窃漏电用户和正常用户，利用那些基础数据提取窃漏电用户的关键特征，从而构建出窃漏电用户的识别模型。      
       
**<font size=3>原始资料</font>**    
原始资料包括：    
1.三个用户的用电量数据，其中有些数据缺失，需要用插值法补全。      
2.已经构建完成的专家样本数据，包括电量趋势下降指标、线损指标、告警类指标和是否窃漏电。      
          
**<font size=3>实战目的</font>**     
1.用拉格朗日插值法补全缺失的数据。       
2.用神经网络和CART决策树分别构建窃漏电用户识别模型。      
3.绘制ROC曲线比较两模型的优劣。       
        
**<font size=3>代码部分</font>**      
**1.拉格朗日插值代码**       
{% codeblock lang:python %}
# !/usr/bin/env python

# _*_ coding: utf-8 _*_

# 使用拉格朗日插值法填入空缺值

import pandas as pd
from scipy.interpolate import lagrange

inputfile = '/Users/Mac/Desktop/missing_data.xls'
outputfile = '/Users/Mac/Desktop/processes_missing_data.xls'

data = pd.read_excel(inputfile, header=None)    # 读入文件

def ployinterp_column(s, n, k=5):       # 定义插值函数
    y = s[list(range(n-k, n)) + list(range(n+1, n+1+k))]    # k为插值前后距离
    y = y[y.notnull()]
    return lagrange(y.index, list(y))(n)

# 检查每列中的每个值是否为空值，并对空值进行插值

for i in data.columns:
    for j in range(len(data)):
        if (data[i].isnull())[j]:
            data[i][j] = ployinterp_column(data[i], j)

data.to_excel(outputfile, header=None, index = False)
{% endcodeblock %}      
       
**2.神经网络模型代码**        
对模型进行训练，并绘制混淆矩阵。
{% codeblock lang:python %}
# !/usr/bin/env python

# _*_ coding: utf-8 _*_

import pandas as pd
from random import shuffle  # 导入随机函数shuffle，打乱数据

inputfile = '/Users/Mac/Desktop/model.xls'
data = pd.read_excel(inputfile)
data = data.as_matrix()
shuffle(data)   # 将数据打乱


# 将文件分割为训练部分和测试部分
p=0.8
train = data[:int(len(data)*p),:]   # 前80%为训练部分
test = data[int(len(data)*p):,:]    # 后20%为测试部分

# 构建神经网络模型
from keras.models import Sequential
from keras.layers.core import Dense, Activation


netfile = '/Users/Mac/Desktop/net_model.h5'     # 创建保存模型的文件
net = Sequential()
net.add(Dense(units=10,input_dim=3))    # input_dim表示输入层节点数量，unit表示隐含层节点数量
net.add(Activation('relu'))     # 设置隐含层激活函数
net.add(Dense(1))       # 设置输入层节点
net.add(Activation('sigmoid'))      # 设置输入层激活函数
net.compile(loss = 'binary_crossentropy', optimizer='adam')

net.fit(train[:,:3], train[:,3], epochs=1000, batch_size=1)

predict_result = net.predict_classes(train[:,:3]).reshape(len(train))
net.save_weights(netfile)   # 保存模型权重

from cm_plot import *
cm_plot(train[:,3],predict_result).show()
{% endcodeblock %}
运行结果如下图：      
      
![图片出来了吗]( https://raw.githubusercontent.com/dongyingdepingguo/dongyingdepingguo.github.io/master/2018/07/01/%E7%94%B5%E5%8A%9B%E7%AA%83%E6%BC%8F%E7%94%B5%E7%94%A8%E6%88%B7%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5.png '神经网络模型的混淆矩阵')      
对模型进行测试，并绘制ROC曲线。
{% codeblock lang:python %}
import pandas as pd
from random import shuffle  # 导入随机函数shuffle，打乱数据

inputfile = '/Users/Mac/Desktop/model.xls'
data = pd.read_excel(inputfile)
data = data.as_matrix()
shuffle(data)   # 将数据打乱


# 将文件分割为训练部分和测试部分
p=0.8
train = data[:int(len(data)*p),:]   # 前80%为训练部分
test = data[int(len(data)*p):,:]    # 后20%为测试部分

# 对模型进行测试
from keras.models import Sequential
from sklearn.metrics import roc_curve
import matplotlib.pyplot as plt
from keras.layers.core import Dense, Activation

net = Sequential()      # 设置网络结构，要保证跟先前训练的结构一样
net.add(Dense(units=10,input_dim=3))    
net.add(Activation('relu'))    
net.add(Dense(1))       
net.add(Activation('sigmoid'))     
net.compile(loss = 'binary_crossentropy', optimizer='adam')
net.load_weights('/Users/Mac/Desktop/net_model.h5')     # 载入之前保存的权重

predict_result = net.predict(test[:,:3]).reshape(len(test))
fpr, tpr, thresholds = roc_curve(test[:,3], predict_result, pos_label=1)
plt.plot(fpr, tpr, linewidth = 2, label = 'ROC of LM')
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.xlim(0,1.05)
plt.ylim(0,1.05)
plt.legend(loc=4)
plt.show()

{% endcodeblock %}
然而，诡异的是同一个模型出现不同的ROC曲线，如下图：    
        
![图片出来了吗]( https://raw.githubusercontent.com/dongyingdepingguo/dongyingdepingguo.github.io/master/2018/07/01/%E7%94%B5%E5%8A%9B%E7%AA%83%E6%BC%8F%E7%94%B5%E7%94%A8%E6%88%B7%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%9C%A8%E6%B5%8B%E8%AF%95%E6%A0%B7%E6%9C%AC%E4%B8%8B%E7%9A%84ROC%E6%9B%B2%E7%BA%BF1.png '神经网络模型在测试样本下的ROC曲线-1')      
           
![图片出来了吗]( https://raw.githubusercontent.com/dongyingdepingguo/dongyingdepingguo.github.io/master/2018/07/01/%E7%94%B5%E5%8A%9B%E7%AA%83%E6%BC%8F%E7%94%B5%E7%94%A8%E6%88%B7%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%9C%A8%E6%B5%8B%E8%AF%95%E6%A0%B7%E6%9C%AC%E4%B8%8B%E7%9A%84ROC%E6%9B%B2%E7%BA%BF2.png '神经网络模型在测试样本下的ROC曲线-2')
         
![图片出来了吗]( https://raw.githubusercontent.com/dongyingdepingguo/dongyingdepingguo.github.io/master/2018/07/01/%E7%94%B5%E5%8A%9B%E7%AA%83%E6%BC%8F%E7%94%B5%E7%94%A8%E6%88%B7%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%9C%A8%E6%B5%8B%E8%AF%95%E6%A0%B7%E6%9C%AC%E4%B8%8B%E7%9A%84ROC%E6%9B%B2%E7%BA%BF3.png '神经网络模型在测试样本下的ROC曲线-3')
        
**3.CART决策树模型代码**      
训练模型，并绘制混淆矩阵。    
{% codeblock lang:python %}
# 数据前处理的代码重复部分略去
# 构建CART决策树模型
from sklearn.tree import DecisionTreeClassifier

treefile = '/Users/Mac/Desktop/tree.pkl'
tree = DecisionTreeClassifier()
tree.fit(train[:,:3],train[:,3])

from sklearn.externals import joblib
joblib.dump(tree, treefile)     # 这里使用joblib模块来保存模型数据

from cm_plot import *
cm_plot(train[:,3], tree.predict(train[:,:3])).show()
{% endcodeblock %}
结果如下图：       
        
![这里是图片]( https://raw.githubusercontent.com/dongyingdepingguo/dongyingdepingguo.github.io/master/2018/07/01/%E7%94%B5%E5%8A%9B%E7%AA%83%E6%BC%8F%E7%94%B5%E7%94%A8%E6%88%B7%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB/%E5%86%B3%E7%AD%96%E6%A0%91/CART%E5%86%B3%E7%AD%96%E6%A0%91%E7%9A%84%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5.png 'CART决策树的混淆矩阵')     
         
模型测试，并绘制ROC曲线。    
{% codeblock lang:python %}
# 数据前处理部分略去
from sklearn.metrics import roc_curve
import matplotlib.pyplot as plt
from sklearn.externals import joblib

tree = joblib.load('/Users/Mac/Desktop/tree.pkl')

fpr, tpr, thresholds = roc_curve(test[:,3], tree.predict_proba(test[:,:3])[:,1],pos_label=1)
plt.plot(fpr, tpr, linewidth = 2, label = 'ROC of CART')
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.ylim(0, 1.05)
plt.xlim(0, 1.05)
plt.legend(loc=4)
plt.show()
{% endcodeblock %}      
结果如下图：      
      
![这里是图片]( https://raw.githubusercontent.com/dongyingdepingguo/dongyingdepingguo.github.io/master/2018/07/01/%E7%94%B5%E5%8A%9B%E7%AA%83%E6%BC%8F%E7%94%B5%E7%94%A8%E6%88%B7%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB/%E5%86%B3%E7%AD%96%E6%A0%91/CART%E5%86%B3%E7%AD%96%E6%A0%91%E5%9C%A8%E6%B5%8B%E8%AF%95%E6%A0%B7%E6%9C%AC%E4%B8%8B%E7%9A%84ROC%E6%9B%B2%E7%BA%BF.png 'CART决策树在测试样本下的ROC曲线')      
      
**<font size=3>模型参数的保存与读取</font>**     
假如一个模型的训练时间很长，为了方便使用，最好的方法就是将训练完毕的模型的参数以文件的形式保存起来，下次使用时直接加载就可以了。上例中就涉及到模型的保存与读取。一般通过两种方法来保存模型。      
     
**1.python自带的pickle**      
{% codeblock lang:python %}
import pickle
# 保存名为tree的决策树模型
f = open('/Users/Mac/Desktop/tree.pickle','wb')
pickle.dump(tree, f)
f.close()

# 加载模型
f = open('/Users/Mac/Desktop/tree.pickle','rb')
tree1 = pickle.load(f)
f.close()
# 然后就可以使用tree1
{% endcodeblock %}
      
**2.使用sklearn中的模块joblib**
{% codeblock lang:python %}
from sklearn.externals import joblib
# 保存名为tree的决策树模型
joblib.dump(tree, '/Users/Mac/Desktop/tree.pkl')

# 加载模型
tree1 = joblib.load('/Users/Mac/Desktop/tree.pkl')
{% endcodeblock %}      
据官网说第二种速度更快。       
       
但这两种方法在保存神经网络模型时，均会出现以下错误：    
{% codeblock lang:python %}
TypeError: can't pickle _thread.RLock objects
{% endcodeblock %}
查了很多资料，找不到原因，初步猜测知识盲点在进程与线程那节。神经网络模型参数的保存与加载完全可以用其自带的save_weights()和load_weights()。需要注意的是，如果想将权重载入与先前训练时结构不同的模型（比如输出层节点数不同），需要设置参数by_name=True，即 model.load_weights(filepath,by_name=True)。      
         
**参考文章**       
1.{% link Keras学习笔记四：序贯模型 https://blog.csdn.net/zhuzuwei/article/details/78991743 %}      
2.{% link 序列化和反序列化模块pickle介绍 | Python库 https://www.jianshu.com/p/5f936abf31f7 %}        
3.{% link 保存训练好的机器学习模型 https://blog.csdn.net/u012328159/article/details/79255805 %}      
4.{% link Python数据分析与挖掘实战 https://book.douban.com/subject/26677686/ %}