---
title: 电力窃漏电用户自动识别-拓展思考
comments: false
date: 2018-07-10 18:35:12
tags: 数据分析
categories: 技术篇
---
<font color=blue>前言：这节是1.1的拓展思考，任务是根据汽车销售行业的纳税人的各个属性，建立偷漏税识别模型，识别偷漏税纳税人。</font>       
      
**<font size=3>原始资料</font>**    
原始资料包括销售类型、销售模式、平均毛利等纳税人的各个属性，一共124条数据，没有缺失数据，因此不需要补全。但有些属性如销售类型，是以中文形式呈现的，需要用数字来替换才能建立模型。    
      
![这是图片]( https://raw.githubusercontent.com/dongyingdepingguo/dongyingdepingguo.github.io/master/2018/07/10/%E7%94%B5%E5%8A%9B%E7%AA%83%E6%BC%8F%E7%94%B5%E7%94%A8%E6%88%B7%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB-%E6%8B%93%E5%B1%95%E6%80%9D%E8%80%83/%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%96%99.png '原始资料')
     
**<font size=3>模型部分</font>**     
**1.1神经网络模型**     
{% codeblock lang:python %}
# !/usr/bin/env python

# _*_ coding: utf-8 _*_

# 神经网络模型

import pandas as pd
from random import shuffle

# 数据前处理部分
input_filename = '/Users/Mac/Desktop/拓展思考样本数据.xls'
data = pd.read_excel(input_filename)

for i in range(len(data[u'销售类型'].value_counts().index)):
    data[u'销售类型'][data[u'销售类型']==data[u'销售类型'].value_counts().index[i]] = i

for j in range(len(data[u'销售模式'].value_counts().index)):
    data[u'销售模式'][data[u'销售模式'] == data[u'销售模式'].value_counts().index[j]] = j

data[u'输出'][data[u'输出'] == '正常'] = 0
data[u'输出'][data[u'输出'] == '异常'] = 1
data = data.as_matrix()
shuffle(data)

p = 0.8
train = data[:int(len(data)*p),:]
test = data[int(len(data)*p):,:]

x = train[:, 1:-1]
y = train[:, -1]

# 构建神经网络模型
from keras.models import Sequential
from keras.layers.core import Dense, Activation

netfile = '/Users/Mac/Desktop/net_actual.h5'
net = Sequential()
net.add(Dense(units=20, input_dim=14))      # 设置各项参数
net.add(Activation('relu'))
net.add(Dense(1))
net.add(Activation('sigmoid'))
net.compile(loss='binary_crossentropy', optimizer='adam')
net.fit(x, y, epochs=1000, batch_size=1)

predict_result = net.predict_classes(x).reshape(len(train))
predict_result2 = net.predict_classes(test[:, 1:-1]).reshape(len(test))
net.save_weights(netfile)

from cm_plot import *
cm_plot(y.astype('int'), predict_result).show()     # 绘制训练结果混淆矩阵
cm_plot(test[:, -1].astype('int'), predict_result2).show()      # 绘制测试结果混淆矩阵

# 绘制ROC曲线
import matplotlib.pyplot as plt
from sklearn.metrics import roc_curve

predict_result = net.predict_classes(test[:,1:-1]).reshape(len(test))
fpr, tpr ,thresholds = roc_curve(test[:, -1].astype('int'), predict_result2, pos_label=1)
plt.plot(fpr, tpr, linewidth = 2, label = 'ROC of LM')
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.xlim(0, 1.05)
plt.ylim(0, 1.05)
plt.legend(loc=4)
plt.show()
{% endcodeblock %}
**1.2模型结果**        
这是神经网络模型的训练和测试结果的混淆矩阵，从结果看模型还是可以的。     
       
![图片出来了吗]( https://raw.githubusercontent.com/dongyingdepingguo/dongyingdepingguo.github.io/master/2018/07/10/%E7%94%B5%E5%8A%9B%E7%AA%83%E6%BC%8F%E7%94%B5%E7%94%A8%E6%88%B7%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB-%E6%8B%93%E5%B1%95%E6%80%9D%E8%80%83/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AE%AD%E7%BB%83%E7%BB%93%E6%9E%9C%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5.png '神经网络训练结果混淆矩阵')
     
![图片出来了吗]( https://raw.githubusercontent.com/dongyingdepingguo/dongyingdepingguo.github.io/master/2018/07/10/%E7%94%B5%E5%8A%9B%E7%AA%83%E6%BC%8F%E7%94%B5%E7%94%A8%E6%88%B7%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB-%E6%8B%93%E5%B1%95%E6%80%9D%E8%80%83/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5.png '神经网络测试结果混淆矩阵')     
ROC曲线有点诡异。     
     
![图片出来了吗]( https://raw.githubusercontent.com/dongyingdepingguo/dongyingdepingguo.github.io/master/2018/07/10/%E7%94%B5%E5%8A%9B%E7%AA%83%E6%BC%8F%E7%94%B5%E7%94%A8%E6%88%B7%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB-%E6%8B%93%E5%B1%95%E6%80%9D%E8%80%83/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CROC%E6%9B%B2%E7%BA%BF.png '神经网络模型ROC曲线')

**2.1决策树模型**       
{% codeblock lang:python %}
# !/usr/bin/env python

# _*_ coding: utf-8 _*_

# 决策树模型

# 数据前处理部分
import pandas as pd
from random import shuffle

input_filename = '/Users/Mac/Desktop/拓展思考样本数据.xls'
data = pd.read_excel(input_filename)

for i in range(len(data[u'销售类型'].value_counts().index)):
    data[u'销售类型'][data[u'销售类型']==data[u'销售类型'].value_counts().index[i]] = i

for j in range(len(data[u'销售模式'].value_counts().index)):
    data[u'销售模式'][data[u'销售模式'] == data[u'销售模式'].value_counts().index[j]] = j

data[u'输出'][data[u'输出'] == '正常'] = 0
data[u'输出'][data[u'输出'] == '异常'] = 1
data = data.as_matrix()
shuffle(data)

p = 0.8
train = data[:int(len(data)*p),:]
test = data[int(len(data)*p):,:]

x = train[:, 1:-1]
y = train[:, -1]

# 构建决策树模型
from sklearn.tree import DecisionTreeClassifier

treeflie = '/Users/Mac/Desktop/tree_actual.pkl'
tree = DecisionTreeClassifier()
tree.fit(x, y.astype('int'))
predict_result = tree.predict(x)
predict_result2 = tree.predict(test[:, 1:-1])

from sklearn.externals import joblib
joblib.dump(tree, treeflie)

# 绘制混淆矩阵
from cm_plot import *
cm_plot(y.astype('int'), predict_result).show()
cm_plot(test[:, -1].astype('int'), predict_result2).show()

from sklearn.metrics import roc_curve
import matplotlib.pyplot as plt

# 绘制ROC曲线
fpr, tpr, thresholds = roc_curve(test[:, -1].astype('int'), predict_result2, pos_label=1)
plt.plot(fpr, tpr, linewidth=2, label = 'ROC of CART')
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.xlim(0, 1.05)
plt.ylim(0, 1.05)
plt.legend(loc=4)
plt.show()
{% endcodeblock %} 
**2.2模型结果**      
从混淆矩阵和ROC曲线上来看，决策树要比神经网络稍好一些。      
       
![这是图片]( https://raw.githubusercontent.com/dongyingdepingguo/dongyingdepingguo.github.io/master/2018/07/10/%E7%94%B5%E5%8A%9B%E7%AA%83%E6%BC%8F%E7%94%B5%E7%94%A8%E6%88%B7%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB-%E6%8B%93%E5%B1%95%E6%80%9D%E8%80%83/%E5%86%B3%E7%AD%96%E6%A0%91%E6%A8%A1%E5%9E%8B/%E5%86%B3%E7%AD%96%E6%A0%91%E8%AE%AD%E7%BB%83%E7%BB%93%E6%9E%9C%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5.png '决策树训练结果混淆矩阵')
       
![这是图片]( https://raw.githubusercontent.com/dongyingdepingguo/dongyingdepingguo.github.io/master/2018/07/10/%E7%94%B5%E5%8A%9B%E7%AA%83%E6%BC%8F%E7%94%B5%E7%94%A8%E6%88%B7%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB-%E6%8B%93%E5%B1%95%E6%80%9D%E8%80%83/%E5%86%B3%E7%AD%96%E6%A0%91%E6%A8%A1%E5%9E%8B/%E5%86%B3%E7%AD%96%E6%A0%91%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5.png '决策树测试结果混淆矩阵')
    
![这是图片]( https://raw.githubusercontent.com/dongyingdepingguo/dongyingdepingguo.github.io/master/2018/07/10/%E7%94%B5%E5%8A%9B%E7%AA%83%E6%BC%8F%E7%94%B5%E7%94%A8%E6%88%B7%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB-%E6%8B%93%E5%B1%95%E6%80%9D%E8%80%83/%E5%86%B3%E7%AD%96%E6%A0%91%E6%A8%A1%E5%9E%8B/%E5%86%B3%E7%AD%96%E6%A0%91ROC%E6%9B%B2%E7%BA%BF.png '决策树ROC曲线') 
从训练结果的混淆矩阵上来看，两个模型全部都预测正确，然而神经网络的TP=26，TN=73，决策树TP=27，TN=72，不知道这是啥情况。
        
        
**3.1逻辑回归模型**       
我最早的想法是主成分分析+神经网络，因为数据属性太多，主成分分析可以修剪属性，再用神经网络预测。主成分分析结果是保留两个属性，但是我找不到那两个属性到底是啥。最后想到直接用逻辑回归看看。     
{% codeblock lang:python %}
# !/usr/bin/env python

# _*_ coding: utf-8 _*_

import pandas as pd

input_filename = '/Users/Mac/Desktop/拓展思考样本数据.xls'
data = pd.read_excel(input_filename)

for i in range(len(data[u'销售类型'].value_counts().index)):
    data[u'销售类型'][data[u'销售类型']==data[u'销售类型'].value_counts().index[i]] = i

for j in range(len(data[u'销售模式'].value_counts().index)):
    data[u'销售模式'][data[u'销售模式'] == data[u'销售模式'].value_counts().index[j]] = j

data[u'输出'][data[u'输出'] == '正常'] = 0
data[u'输出'][data[u'输出'] == '异常'] = 1

p = 0.8
train = data.iloc[:int(len(data)*p),:]
test = data.iloc[int(len(data)*p):,:]

x = train.iloc[:, 1:-1]
y = train.iloc[:, -1]

from sklearn.linear_model import LogisticRegression as LR
from sklearn.linear_model import RandomizedLogisticRegression as RLR

rlr = RLR()
rlr.fit(x, y)
rlr.get_support()
print(train.columns[rlr.get_support(indices=True)])
print('有效特征为：%s' %','.join(train.columns[rlr.get_support(indices=True)]))
x = train[train.columns[rlr.get_support(indices=True)]].as_matrix()

lr = LR()
lr.fit(x, y.astype('int'))
print('模型训练结束')
print('模型的平均正确率为：%s'%lr.score(x, y.astype('int')))

X = test[test.columns[rlr.get_support(indices=True)]]
X2 = train[train.columns[rlr.get_support(indices=True)]]
predict_result = lr.predict(X)
predict_result2 = lr.predict(X2)

from cm_plot import *
cm_plot(test.iloc[:,-1].astype('int'), predict_result).show()
cm_plot(train.iloc[:,-1].astype('int'), predict_result2).show()
{% endcodeblock %}
**3.2模型结果**     
然而，结果......！！       
{% codeblock lang:python %}
有效特征为：汽车销售平均毛利,整体理论税负
模型训练结束
模型的平均正确率为：0.636363636364
{% endcodeblock %}
混淆矩阵不堪入目。    
     
![这是图片]( https://raw.githubusercontent.com/dongyingdepingguo/dongyingdepingguo.github.io/master/2018/07/10/%E7%94%B5%E5%8A%9B%E7%AA%83%E6%BC%8F%E7%94%B5%E7%94%A8%E6%88%B7%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB-%E6%8B%93%E5%B1%95%E6%80%9D%E8%80%83/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E7%BB%93%E6%9E%9C%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5.png '逻辑回归模型训练结果混淆矩阵')  
       
![此乃图片]( https://raw.githubusercontent.com/dongyingdepingguo/dongyingdepingguo.github.io/master/2018/07/10/%E7%94%B5%E5%8A%9B%E7%AA%83%E6%BC%8F%E7%94%B5%E7%94%A8%E6%88%B7%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB-%E6%8B%93%E5%B1%95%E6%80%9D%E8%80%83/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E7%BB%93%E6%9E%9C%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5.png '逻辑回归模型测试结果混淆矩阵')   
<font color=blue>后记：《python数据分析与挖掘实战》是一本烂书，书中的内容错的不计其数，从上面copy的混淆矩阵的代码也错了，无力吐槽。</font>      
      
**参考文章**    
1.{% link python数据分析与挖掘实战 第六章 拓展思考 https://blog.csdn.net/qq_26978413/article/details/78234414 %}    
2.{% link 《Python数据分析与挖掘实战》第六章学习拓展——偷漏税用户识别 https://blog.csdn.net/sinat_33519513/article/details/74086061 %}   
3.{% link Python数据分析与挖掘实战 https://book.douban.com/subject/26677686/ %}